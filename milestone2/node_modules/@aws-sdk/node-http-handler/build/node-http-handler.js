"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var https = require("https");
var http = require("http");
var querystring_builder_1 = require("@aws-sdk/querystring-builder");
var set_connection_timeout_1 = require("./set-connection-timeout");
var set_socket_timeout_1 = require("./set-socket-timeout");
var write_request_body_1 = require("./write-request-body");
var NodeHttpHandler = /** @class */ (function () {
    function NodeHttpHandler(httpOptions) {
        if (httpOptions === void 0) { httpOptions = {}; }
        this.httpOptions = httpOptions;
        var keepAlive = httpOptions.keepAlive;
        this.httpAgent = new http.Agent({ keepAlive: keepAlive });
        this.httpsAgent = new https.Agent({ keepAlive: keepAlive });
    }
    NodeHttpHandler.prototype.destroy = function () {
        this.httpAgent.destroy();
        this.httpsAgent.destroy();
    };
    NodeHttpHandler.prototype.handle = function (request, options) {
        var _this = this;
        // determine which http(s) client to use
        var isSSL = request.protocol === "https:";
        var httpClient = isSSL ? https : http;
        var path = request.path;
        if (request.query) {
            var queryString = querystring_builder_1.buildQueryString(request.query);
            if (queryString) {
                path += "?" + queryString;
            }
        }
        var nodeHttpsOptions = {
            headers: request.headers,
            host: request.hostname,
            method: request.method,
            path: path,
            port: request.port,
            agent: isSSL ? this.httpsAgent : this.httpAgent
        };
        return new Promise(function (resolve, reject) {
            var abortSignal = options && options.abortSignal;
            var _a = _this.httpOptions, connectionTimeout = _a.connectionTimeout, socketTimeout = _a.socketTimeout;
            // if the request was already aborted, prevent doing extra work
            if (abortSignal && abortSignal.aborted) {
                var abortError = new Error("Request aborted");
                abortError.name = "AbortError";
                reject(abortError);
                return;
            }
            // create the http request
            var req = httpClient.request(nodeHttpsOptions, function (res) {
                var e_1, _a;
                var httpHeaders = res.headers;
                var transformedHeaders = {};
                try {
                    for (var _b = tslib_1.__values(Object.keys(httpHeaders)), _c = _b.next(); !_c.done; _c = _b.next()) {
                        var name = _c.value;
                        var headerValues = httpHeaders[name];
                        transformedHeaders[name] = Array.isArray(headerValues)
                            ? headerValues.join(",")
                            : headerValues;
                    }
                }
                catch (e_1_1) { e_1 = { error: e_1_1 }; }
                finally {
                    try {
                        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                    }
                    finally { if (e_1) throw e_1.error; }
                }
                var httpResponse = {
                    statusCode: res.statusCode || -1,
                    headers: transformedHeaders,
                    body: res
                };
                resolve(httpResponse);
            });
            req.on("error", reject);
            // wire-up any timeout logic
            set_connection_timeout_1.setConnectionTimeout(req, reject, connectionTimeout);
            set_socket_timeout_1.setSocketTimeout(req, reject, socketTimeout);
            // wire-up abort logic
            if (abortSignal) {
                abortSignal.onabort = function () {
                    // ensure request is destroyed
                    req.abort();
                    var abortError = new Error("Request aborted");
                    abortError.name = "AbortError";
                    reject(abortError);
                };
            }
            write_request_body_1.writeRequestBody(req, request);
        });
    };
    return NodeHttpHandler;
}());
exports.NodeHttpHandler = NodeHttpHandler;
//# sourceMappingURL=node-http-handler.js.map