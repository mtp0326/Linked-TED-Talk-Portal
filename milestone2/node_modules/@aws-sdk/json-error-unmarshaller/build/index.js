"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var response_metadata_extractor_1 = require("@aws-sdk/response-metadata-extractor");
var util_error_constructor_1 = require("@aws-sdk/util-error-constructor");
exports.jsonErrorUnmarshaller = function (operation, response, errorBodyParser) {
    var e_1, _a;
    var body = response.body;
    var errors = operation.errors, operationName = operation.name;
    var errorCodeFieldNameList = [
        '__type',
        'code',
    ];
    var errorCodeHeaderName = 'x-amzn-errortype';
    var errorName = parseErrorCodeFromHeader(response.headers, errorCodeHeaderName) ||
        parseErrorCodeFromBody(body, errorCodeFieldNameList) ||
        undefined;
    if (!errorName) {
        return util_error_constructor_1.initServiceException(new Error(), {
            $metadata: response_metadata_extractor_1.extractMetadata(response),
            operationName: operationName,
        });
    }
    var messageLocationList = ['message', 'Message', 'errorMessage'];
    var errorMessage = parseJsonMessage(body, messageLocationList) || '';
    try {
        //parse other properties other than name and message
        for (var errors_1 = tslib_1.__values(errors), errors_1_1 = errors_1.next(); !errors_1_1.done; errors_1_1 = errors_1.next()) {
            var errorShape = errors_1_1.value;
            var errorStructure = errorShape.shape;
            if (errorStructure.exceptionCode === errorName ||
                (!errorStructure.exceptionCode && errorStructure.exceptionType === errorName)) {
                var rawException = errorStructure.members
                    ? errorBodyParser.parse(errorShape, body)
                    : {};
                return util_error_constructor_1.initServiceException(new Error(), {
                    $metadata: response_metadata_extractor_1.extractMetadata(response),
                    message: errorMessage,
                    name: errorName,
                    rawException: rawException,
                    operationName: operationName,
                });
            }
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (errors_1_1 && !errors_1_1.done && (_a = errors_1.return)) _a.call(errors_1);
        }
        finally { if (e_1) throw e_1.error; }
    }
    //parsable exception but not documented in API
    var option = {
        $metadata: response_metadata_extractor_1.extractMetadata(response),
        name: errorName,
        message: errorMessage,
    };
    return util_error_constructor_1.initServiceException(new Error(), option);
};
function parseErrorCodeFromHeader(headers, targetHeaderName) {
    var errorCode = headers[targetHeaderName];
    return typeof errorCode === 'string' ? errorCode.split(':')[0] : undefined;
}
function parseErrorCodeFromBody(body, errorCodeFieldNameList) {
    var e_2, _a;
    if (body) {
        var errorOBJ = JSON.parse(body);
        try {
            for (var errorCodeFieldNameList_1 = tslib_1.__values(errorCodeFieldNameList), errorCodeFieldNameList_1_1 = errorCodeFieldNameList_1.next(); !errorCodeFieldNameList_1_1.done; errorCodeFieldNameList_1_1 = errorCodeFieldNameList_1.next()) {
                var fieldName = errorCodeFieldNameList_1_1.value;
                if (errorOBJ[fieldName]) {
                    return errorOBJ[fieldName].split('#').pop();
                }
            }
        }
        catch (e_2_1) { e_2 = { error: e_2_1 }; }
        finally {
            try {
                if (errorCodeFieldNameList_1_1 && !errorCodeFieldNameList_1_1.done && (_a = errorCodeFieldNameList_1.return)) _a.call(errorCodeFieldNameList_1);
            }
            finally { if (e_2) throw e_2.error; }
        }
    }
}
function parseJsonMessage(body, messageLocations) {
    return parseErrorCodeFromBody(body, messageLocations);
}
//# sourceMappingURL=index.js.map