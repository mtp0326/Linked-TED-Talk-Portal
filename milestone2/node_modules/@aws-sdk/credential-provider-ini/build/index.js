"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var property_provider_1 = require("@aws-sdk/property-provider");
var shared_ini_file_loader_1 = require("@aws-sdk/shared-ini-file-loader");
var DEFAULT_PROFILE = "default";
exports.ENV_PROFILE = "AWS_PROFILE";
function isStaticCredsProfile(arg) {
    return (Boolean(arg) &&
        typeof arg === "object" &&
        typeof arg.aws_access_key_id === "string" &&
        typeof arg.aws_secret_access_key === "string" &&
        ["undefined", "string"].indexOf(typeof arg.aws_session_token) > -1);
}
function isAssumeRoleProfile(arg) {
    return (Boolean(arg) &&
        typeof arg === "object" &&
        typeof arg.role_arn === "string" &&
        typeof arg.source_profile === "string" &&
        ["undefined", "string"].indexOf(typeof arg.role_session_name) > -1 &&
        ["undefined", "string"].indexOf(typeof arg.external_id) > -1 &&
        ["undefined", "string"].indexOf(typeof arg.mfa_serial) > -1);
}
/**
 * Creates a credential provider that will read from ini files and supports
 * role assumption and multi-factor authentication.
 */
function fromIni(init) {
    if (init === void 0) { init = {}; }
    return function () {
        return parseKnownFiles(init).then(function (profiles) {
            return resolveProfileData(getMasterProfileName(init), profiles, init);
        });
    };
}
exports.fromIni = fromIni;
function getMasterProfileName(init) {
    return init.profile || process.env[exports.ENV_PROFILE] || DEFAULT_PROFILE;
}
exports.getMasterProfileName = getMasterProfileName;
function resolveProfileData(profileName, profiles, options, visitedProfiles) {
    if (visitedProfiles === void 0) { visitedProfiles = {}; }
    return tslib_1.__awaiter(this, void 0, void 0, function () {
        var _a, data, ExternalId, mfa_serial, RoleArn, _b, RoleSessionName, source_profile, sourceCreds, params, _c, _d, _e;
        return tslib_1.__generator(this, function (_f) {
            switch (_f.label) {
                case 0:
                    data = profiles[profileName];
                    // If this is not the first profile visited, static credentials should be
                    // preferred over role assumption metadata. This special treatment of
                    // second and subsequent hops is to ensure compatibility with the AWS CLI.
                    if (Object.keys(visitedProfiles).length > 0 && isStaticCredsProfile(data)) {
                        return [2 /*return*/, resolveStaticCredentials(data)];
                    }
                    if (!isAssumeRoleProfile(data)) return [3 /*break*/, 4];
                    ExternalId = data.external_id, mfa_serial = data.mfa_serial, RoleArn = data.role_arn, _b = data.role_session_name, RoleSessionName = _b === void 0 ? "aws-sdk-js-" + Date.now() : _b, source_profile = data.source_profile;
                    if (!options.roleAssumer) {
                        throw new property_provider_1.ProviderError("Profile " + profileName + " requires a role to be assumed, but no" +
                            " role assumption callback was provided.", false);
                    }
                    if (source_profile in visitedProfiles) {
                        throw new property_provider_1.ProviderError("Detected a cycle attempting to resolve credentials for profile" +
                            (" " + getMasterProfileName(options) + ". Profiles visited: ") +
                            Object.keys(visitedProfiles).join(", "), false);
                    }
                    sourceCreds = resolveProfileData(source_profile, profiles, options, tslib_1.__assign({}, visitedProfiles, (_a = {}, _a[source_profile] = true, _a)));
                    params = { RoleArn: RoleArn, RoleSessionName: RoleSessionName, ExternalId: ExternalId };
                    if (!mfa_serial) return [3 /*break*/, 2];
                    if (!options.mfaCodeProvider) {
                        throw new property_provider_1.ProviderError("Profile " + profileName + " requires multi-factor authentication," +
                            " but no MFA code callback was provided.", false);
                    }
                    params.SerialNumber = mfa_serial;
                    _c = params;
                    return [4 /*yield*/, options.mfaCodeProvider(mfa_serial)];
                case 1:
                    _c.TokenCode = _f.sent();
                    _f.label = 2;
                case 2:
                    _e = (_d = options).roleAssumer;
                    return [4 /*yield*/, sourceCreds];
                case 3: return [2 /*return*/, _e.apply(_d, [_f.sent(), params])];
                case 4:
                    // If no role assumption metadata is present, attempt to load static
                    // credentials from the selected profile.
                    if (isStaticCredsProfile(data)) {
                        return [2 /*return*/, resolveStaticCredentials(data)];
                    }
                    // If the profile cannot be parsed or contains neither static credentials
                    // nor role assumption metadata, throw an error. This should be considered a
                    // terminal resolution error if a profile has been specified by the user
                    // (whether via a parameter, an environment variable, or another profile's
                    // `source_profile` key).
                    throw new property_provider_1.ProviderError("Profile " + profileName + " could not be found or parsed in shared" +
                        " credentials file.");
            }
        });
    });
}
function parseKnownFiles(init) {
    var _a = init.loadedConfig, loadedConfig = _a === void 0 ? shared_ini_file_loader_1.loadSharedConfigFiles(init) : _a;
    return loadedConfig.then(function (parsedFiles) {
        var configFile = parsedFiles.configFile, credentialsFile = parsedFiles.credentialsFile;
        return tslib_1.__assign({}, configFile, credentialsFile);
    });
}
exports.parseKnownFiles = parseKnownFiles;
function resolveStaticCredentials(profile) {
    return Promise.resolve({
        accessKeyId: profile.aws_access_key_id,
        secretAccessKey: profile.aws_secret_access_key,
        sessionToken: profile.aws_session_token
    });
}
//# sourceMappingURL=index.js.map